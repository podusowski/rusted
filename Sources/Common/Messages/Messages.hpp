/* this file autogenerated by /home/kaptur/dev/rusted/Sources/Common/../External/Cake/Networking/Protocol/protoc.py, do not edit by hand */

#pragma once

#include <stdexcept>
#include <vector>
#include <string>
#include <ostream>
#include <sstream>
#include <memory>

#include "Cake/Networking/Protocol/IWriteBuffer.hpp"
#include "Cake/Networking/Protocol/IReadBuffer.hpp"
#include "Cake/Networking/Protocol/BinaryCoder.hpp"
#include "Cake/Networking/Protocol/BinaryDecoder.hpp"
#include "Cake/Networking/Protocol/FcDecoder.hpp"

namespace Common
{
namespace Messages
{

namespace Id
{

enum Messages
{
    InvalidMessage = 0,
    ServerVersionReq = 100,
    ServerVersionResp = 101,
    Exception = 102,
    UserAuthorizationReq = 103,
    UserAuthorizationResp = 104,
    GetPlayerResourcesInfo = 105,
    PlayerResourcesInfo = 106,
    RustedTimeEpochReq = 107,
    RustedTimeEpochResp = 108,
    GetPlayerName = 109,
    PlayerName = 110,
    FetchPlayerShips = 111,
    PlayerShips = 112,
    ShipInfo = 113,
    ObjectIntegrity = 114,
    ChangeShipCourse = 115,
    ShipCourseInfo = 116,
    AsteroidInfo = 117,
    GetVisibleObjects = 118,
    VisibleObjects = 119,
    GetObjectInfo = 120,
    FocusObject = 121,
    SelectObject = 122,
    ObjectCargoInfo = 123,
    FetchAvailableActions = 124,
    AvailableActions = 125,
    ExecuteAction = 126,
    ActionStarted = 127,
    ActionFinished = 128,
    ActionCooldownExpired = 129,
    GlobalCooldownActivated = 130,
    GlobalCooldownExpired = 131,
    EmitMovingMeshEffect = 132,
    EmitExplosionEffect = 133,
    ReloadDatabase = 134
};

} // namespace Id

struct ISerializable
{
    virtual void serialize(Cake::Networking::Protocol::IWriteBuffer &) const = 0;
    virtual void unserialize(Cake::Networking::Protocol::IReadBuffer &) = 0;
    virtual void unserialize(const Cake::Serialization::Fc &) = 0;
    virtual std::string toString() const = 0;
    virtual ~ISerializable() {}
};

struct AbstractMessage : public ISerializable
{
    virtual Id::Messages getId() const = 0;
    virtual ~AbstractMessage() {}
};

struct ShipId : public ISerializable
{
    int id;
    
    
    explicit ShipId(const int & _id) :
    id(_id)
    {
    }
    
    bool operator ==(const ShipId & other) const
    {
        return id == other.id;
    }
    
    bool operator !=(const ShipId & other) const
    {
        return !(*this == other);
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << id;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> id;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> id;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ShipId ( ";
        ss << "id:" << id << " ";
        ss << ")";
        return ss.str();
    }
    
    ShipId() {}
};

struct Position : public ISerializable
{
    int x;
    int y;
    int z;
    
    
    explicit Position(const int & _x, const int & _y, const int & _z) :
    x(_x), y(_y), z(_z)
    {
    }
    
    bool operator ==(const Position & other) const
    {
        return x == other.x &&
               y == other.y &&
               z == other.z;
    }
    
    bool operator !=(const Position & other) const
    {
        return !(*this == other);
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << x << y << z;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> x >> y >> z;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> x >> y >> z;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "Position ( ";
        ss << "x:" << x << " ";
        ss << "y:" << y << " ";
        ss << "z:" << z << " ";
        ss << ")";
        return ss.str();
    }
    
    Position() {}
};

struct ObjectId : public ISerializable
{
    int id;
    
    
    explicit ObjectId(const int & _id) :
    id(_id)
    {
    }
    
    bool operator ==(const ObjectId & other) const
    {
        return id == other.id;
    }
    
    bool operator !=(const ObjectId & other) const
    {
        return !(*this == other);
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << id;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> id;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> id;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ObjectId ( ";
        ss << "id:" << id << " ";
        ss << ")";
        return ss.str();
    }
    
    ObjectId() {}
};

struct AvailableActionPlayerParameter : public ISerializable
{
    std::string name;
    
    
    explicit AvailableActionPlayerParameter(const std::string & _name) :
    name(_name)
    {
    }
    
    bool operator ==(const AvailableActionPlayerParameter & other) const
    {
        return name == other.name;
    }
    
    bool operator !=(const AvailableActionPlayerParameter & other) const
    {
        return !(*this == other);
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << name;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> name;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> name;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "AvailableActionPlayerParameter ( ";
        ss << "name:" << name << " ";
        ss << ")";
        return ss.str();
    }
    
    AvailableActionPlayerParameter() {}
};

struct AvailableAction : public ISerializable
{
    int id;
    int parameter;
    std::string name;
    std::string description;
    
    
    explicit AvailableAction(const int & _id, const int & _parameter, const std::string & _name, const std::string & _description) :
    id(_id), parameter(_parameter), name(_name), description(_description)
    {
    }
    
    bool operator ==(const AvailableAction & other) const
    {
        return id == other.id &&
               parameter == other.parameter &&
               name == other.name &&
               description == other.description;
    }
    
    bool operator !=(const AvailableAction & other) const
    {
        return !(*this == other);
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << id << parameter << name << description;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> id >> parameter >> name >> description;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> id >> parameter >> name >> description;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "AvailableAction ( ";
        ss << "id:" << id << " ";
        ss << "parameter:" << parameter << " ";
        ss << "name:" << name << " ";
        ss << "description:" << description << " ";
        ss << ")";
        return ss.str();
    }
    
    AvailableAction() {}
};

struct ServerVersionReq : public AbstractMessage
{
    
    
    
    bool operator ==(const ServerVersionReq & other) const
    {
        return true;
    }
    
    bool operator !=(const ServerVersionReq & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::ServerVersionReq;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId();
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ServerVersionReq ( ";
        ss << ")";
        return ss.str();
    }
    
    ServerVersionReq() {}
};

struct ServerVersionResp : public AbstractMessage
{
    std::string version;
    
    
    explicit ServerVersionResp(const std::string & _version) :
    version(_version)
    {
    }
    
    bool operator ==(const ServerVersionResp & other) const
    {
        return version == other.version;
    }
    
    bool operator !=(const ServerVersionResp & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::ServerVersionResp;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << version;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> version;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> version;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ServerVersionResp ( ";
        ss << "version:" << version << " ";
        ss << ")";
        return ss.str();
    }
    
    ServerVersionResp() {}
};

struct Exception : public AbstractMessage
{
    std::string description;
    
    
    explicit Exception(const std::string & _description) :
    description(_description)
    {
    }
    
    bool operator ==(const Exception & other) const
    {
        return description == other.description;
    }
    
    bool operator !=(const Exception & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::Exception;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << description;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> description;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> description;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "Exception ( ";
        ss << "description:" << description << " ";
        ss << ")";
        return ss.str();
    }
    
    Exception() {}
};

struct UserAuthorizationReq : public AbstractMessage
{
    std::string login;
    std::string password;
    
    
    explicit UserAuthorizationReq(const std::string & _login, const std::string & _password) :
    login(_login), password(_password)
    {
    }
    
    bool operator ==(const UserAuthorizationReq & other) const
    {
        return login == other.login &&
               password == other.password;
    }
    
    bool operator !=(const UserAuthorizationReq & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::UserAuthorizationReq;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << login << password;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> login >> password;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> login >> password;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "UserAuthorizationReq ( ";
        ss << "login:" << login << " ";
        ss << "password:" << password << " ";
        ss << ")";
        return ss.str();
    }
    
    UserAuthorizationReq() {}
};

struct UserAuthorizationResp : public AbstractMessage
{
    bool success;
    int player_id;
    
    
    explicit UserAuthorizationResp(const bool & _success, const int & _player_id) :
    success(_success), player_id(_player_id)
    {
    }
    
    bool operator ==(const UserAuthorizationResp & other) const
    {
        return success == other.success &&
               player_id == other.player_id;
    }
    
    bool operator !=(const UserAuthorizationResp & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::UserAuthorizationResp;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << success << player_id;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> success >> player_id;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> success >> player_id;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "UserAuthorizationResp ( ";
        ss << "success:" << success << " ";
        ss << "player_id:" << player_id << " ";
        ss << ")";
        return ss.str();
    }
    
    UserAuthorizationResp() {}
};

struct GetPlayerResourcesInfo : public AbstractMessage
{
    
    
    
    bool operator ==(const GetPlayerResourcesInfo & other) const
    {
        return true;
    }
    
    bool operator !=(const GetPlayerResourcesInfo & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::GetPlayerResourcesInfo;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId();
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "GetPlayerResourcesInfo ( ";
        ss << ")";
        return ss.str();
    }
    
    GetPlayerResourcesInfo() {}
};

struct PlayerResourcesInfo : public AbstractMessage
{
    int helium;
    int carbon;
    
    
    explicit PlayerResourcesInfo(const int & _helium, const int & _carbon) :
    helium(_helium), carbon(_carbon)
    {
    }
    
    bool operator ==(const PlayerResourcesInfo & other) const
    {
        return helium == other.helium &&
               carbon == other.carbon;
    }
    
    bool operator !=(const PlayerResourcesInfo & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::PlayerResourcesInfo;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << helium << carbon;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> helium >> carbon;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> helium >> carbon;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "PlayerResourcesInfo ( ";
        ss << "helium:" << helium << " ";
        ss << "carbon:" << carbon << " ";
        ss << ")";
        return ss.str();
    }
    
    PlayerResourcesInfo() {}
};

struct RustedTimeEpochReq : public AbstractMessage
{
    
    
    
    bool operator ==(const RustedTimeEpochReq & other) const
    {
        return true;
    }
    
    bool operator !=(const RustedTimeEpochReq & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::RustedTimeEpochReq;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId();
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "RustedTimeEpochReq ( ";
        ss << ")";
        return ss.str();
    }
    
    RustedTimeEpochReq() {}
};

struct RustedTimeEpochResp : public AbstractMessage
{
    int seconds;
    int miliSeconds;
    
    
    explicit RustedTimeEpochResp(const int & _seconds, const int & _miliSeconds) :
    seconds(_seconds), miliSeconds(_miliSeconds)
    {
    }
    
    bool operator ==(const RustedTimeEpochResp & other) const
    {
        return seconds == other.seconds &&
               miliSeconds == other.miliSeconds;
    }
    
    bool operator !=(const RustedTimeEpochResp & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::RustedTimeEpochResp;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << seconds << miliSeconds;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> seconds >> miliSeconds;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> seconds >> miliSeconds;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "RustedTimeEpochResp ( ";
        ss << "seconds:" << seconds << " ";
        ss << "miliSeconds:" << miliSeconds << " ";
        ss << ")";
        return ss.str();
    }
    
    RustedTimeEpochResp() {}
};

struct GetPlayerName : public AbstractMessage
{
    int id;
    
    
    explicit GetPlayerName(const int & _id) :
    id(_id)
    {
    }
    
    bool operator ==(const GetPlayerName & other) const
    {
        return id == other.id;
    }
    
    bool operator !=(const GetPlayerName & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::GetPlayerName;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << id;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> id;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> id;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "GetPlayerName ( ";
        ss << "id:" << id << " ";
        ss << ")";
        return ss.str();
    }
    
    GetPlayerName() {}
};

struct PlayerName : public AbstractMessage
{
    int id;
    std::string name;
    
    
    explicit PlayerName(const int & _id, const std::string & _name) :
    id(_id), name(_name)
    {
    }
    
    bool operator ==(const PlayerName & other) const
    {
        return id == other.id &&
               name == other.name;
    }
    
    bool operator !=(const PlayerName & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::PlayerName;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << id << name;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> id >> name;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> id >> name;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "PlayerName ( ";
        ss << "id:" << id << " ";
        ss << "name:" << name << " ";
        ss << ")";
        return ss.str();
    }
    
    PlayerName() {}
};

struct FetchPlayerShips : public AbstractMessage
{
    
    
    
    bool operator ==(const FetchPlayerShips & other) const
    {
        return true;
    }
    
    bool operator !=(const FetchPlayerShips & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::FetchPlayerShips;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId();
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "FetchPlayerShips ( ";
        ss << ")";
        return ss.str();
    }
    
    FetchPlayerShips() {}
};

struct PlayerShips : public AbstractMessage
{
    
    std::vector<ShipId> ships;
    
    explicit PlayerShips(const std::vector<ShipId> & _ships) :
    ships(_ships)
    {
    }
    
    bool operator ==(const PlayerShips & other) const
    {
        return ships == other.ships;
    }
    
    bool operator !=(const PlayerShips & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::PlayerShips;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << ships;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> ships;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> ships;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "PlayerShips ( ";
        ss << "ships:( ";
        for (const auto & e : ships)
        {
            ss << e.toString() << " ";
        }
        ss << ") ";
        ss << ")";
        return ss.str();
    }
    
    PlayerShips() {}
};

struct ShipInfo : public AbstractMessage
{
    int id;
    int player_id;
    std::string model;
    int integrity;
    int speed;
    int x;
    int y;
    int z;
    float orientationW;
    float orientationX;
    float orientationY;
    float orientationZ;
    
    
    explicit ShipInfo(const int & _id, const int & _player_id, const std::string & _model, const int & _integrity, const int & _speed, const int & _x, const int & _y, const int & _z, const float & _orientationW, const float & _orientationX, const float & _orientationY, const float & _orientationZ) :
    id(_id), player_id(_player_id), model(_model), integrity(_integrity), speed(_speed), x(_x), y(_y), z(_z), orientationW(_orientationW), orientationX(_orientationX), orientationY(_orientationY), orientationZ(_orientationZ)
    {
    }
    
    bool operator ==(const ShipInfo & other) const
    {
        return id == other.id &&
               player_id == other.player_id &&
               model == other.model &&
               integrity == other.integrity &&
               speed == other.speed &&
               x == other.x &&
               y == other.y &&
               z == other.z &&
               orientationW == other.orientationW &&
               orientationX == other.orientationX &&
               orientationY == other.orientationY &&
               orientationZ == other.orientationZ;
    }
    
    bool operator !=(const ShipInfo & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::ShipInfo;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << id << player_id << model << integrity << speed << x << y << z << orientationW << orientationX << orientationY << orientationZ;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> id >> player_id >> model >> integrity >> speed >> x >> y >> z >> orientationW >> orientationX >> orientationY >> orientationZ;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> id >> player_id >> model >> integrity >> speed >> x >> y >> z >> orientationW >> orientationX >> orientationY >> orientationZ;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ShipInfo ( ";
        ss << "id:" << id << " ";
        ss << "player_id:" << player_id << " ";
        ss << "model:" << model << " ";
        ss << "integrity:" << integrity << " ";
        ss << "speed:" << speed << " ";
        ss << "x:" << x << " ";
        ss << "y:" << y << " ";
        ss << "z:" << z << " ";
        ss << "orientationW:" << orientationW << " ";
        ss << "orientationX:" << orientationX << " ";
        ss << "orientationY:" << orientationY << " ";
        ss << "orientationZ:" << orientationZ << " ";
        ss << ")";
        return ss.str();
    }
    
    ShipInfo() {}
};

struct ObjectIntegrity : public AbstractMessage
{
    int id;
    int integrity;
    
    
    explicit ObjectIntegrity(const int & _id, const int & _integrity) :
    id(_id), integrity(_integrity)
    {
    }
    
    bool operator ==(const ObjectIntegrity & other) const
    {
        return id == other.id &&
               integrity == other.integrity;
    }
    
    bool operator !=(const ObjectIntegrity & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::ObjectIntegrity;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << id << integrity;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> id >> integrity;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> id >> integrity;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ObjectIntegrity ( ";
        ss << "id:" << id << " ";
        ss << "integrity:" << integrity << " ";
        ss << ")";
        return ss.str();
    }
    
    ObjectIntegrity() {}
};

struct ChangeShipCourse : public AbstractMessage
{
    int shipId;
    int x;
    int y;
    int z;
    
    
    explicit ChangeShipCourse(const int & _shipId, const int & _x, const int & _y, const int & _z) :
    shipId(_shipId), x(_x), y(_y), z(_z)
    {
    }
    
    bool operator ==(const ChangeShipCourse & other) const
    {
        return shipId == other.shipId &&
               x == other.x &&
               y == other.y &&
               z == other.z;
    }
    
    bool operator !=(const ChangeShipCourse & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::ChangeShipCourse;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << shipId << x << y << z;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> shipId >> x >> y >> z;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> shipId >> x >> y >> z;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ChangeShipCourse ( ";
        ss << "shipId:" << shipId << " ";
        ss << "x:" << x << " ";
        ss << "y:" << y << " ";
        ss << "z:" << z << " ";
        ss << ")";
        return ss.str();
    }
    
    ChangeShipCourse() {}
};

struct ShipCourseInfo : public AbstractMessage
{
    int objectId;
    int startTimeSeconds;
    int startTimeMiliseconds;
    int initialSpeed;
    
    std::vector<Position> controlPoints;
    
    explicit ShipCourseInfo(const int & _objectId, const int & _startTimeSeconds, const int & _startTimeMiliseconds, const int & _initialSpeed, const std::vector<Position> & _controlPoints) :
    objectId(_objectId), startTimeSeconds(_startTimeSeconds), startTimeMiliseconds(_startTimeMiliseconds), initialSpeed(_initialSpeed), controlPoints(_controlPoints)
    {
    }
    
    bool operator ==(const ShipCourseInfo & other) const
    {
        return objectId == other.objectId &&
               startTimeSeconds == other.startTimeSeconds &&
               startTimeMiliseconds == other.startTimeMiliseconds &&
               initialSpeed == other.initialSpeed &&
               controlPoints == other.controlPoints;
    }
    
    bool operator !=(const ShipCourseInfo & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::ShipCourseInfo;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << objectId << startTimeSeconds << startTimeMiliseconds << initialSpeed << controlPoints;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> objectId >> startTimeSeconds >> startTimeMiliseconds >> initialSpeed >> controlPoints;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> objectId >> startTimeSeconds >> startTimeMiliseconds >> initialSpeed >> controlPoints;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ShipCourseInfo ( ";
        ss << "objectId:" << objectId << " ";
        ss << "startTimeSeconds:" << startTimeSeconds << " ";
        ss << "startTimeMiliseconds:" << startTimeMiliseconds << " ";
        ss << "initialSpeed:" << initialSpeed << " ";
        ss << "controlPoints:( ";
        for (const auto & e : controlPoints)
        {
            ss << e.toString() << " ";
        }
        ss << ") ";
        ss << ")";
        return ss.str();
    }
    
    ShipCourseInfo() {}
};

struct AsteroidInfo : public AbstractMessage
{
    int objectId;
    std::string model;
    int x;
    int y;
    int z;
    
    
    explicit AsteroidInfo(const int & _objectId, const std::string & _model, const int & _x, const int & _y, const int & _z) :
    objectId(_objectId), model(_model), x(_x), y(_y), z(_z)
    {
    }
    
    bool operator ==(const AsteroidInfo & other) const
    {
        return objectId == other.objectId &&
               model == other.model &&
               x == other.x &&
               y == other.y &&
               z == other.z;
    }
    
    bool operator !=(const AsteroidInfo & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::AsteroidInfo;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << objectId << model << x << y << z;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> objectId >> model >> x >> y >> z;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> objectId >> model >> x >> y >> z;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "AsteroidInfo ( ";
        ss << "objectId:" << objectId << " ";
        ss << "model:" << model << " ";
        ss << "x:" << x << " ";
        ss << "y:" << y << " ";
        ss << "z:" << z << " ";
        ss << ")";
        return ss.str();
    }
    
    AsteroidInfo() {}
};

struct GetVisibleObjects : public AbstractMessage
{
    
    
    
    bool operator ==(const GetVisibleObjects & other) const
    {
        return true;
    }
    
    bool operator !=(const GetVisibleObjects & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::GetVisibleObjects;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId();
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "GetVisibleObjects ( ";
        ss << ")";
        return ss.str();
    }
    
    GetVisibleObjects() {}
};

struct VisibleObjects : public AbstractMessage
{
    
    std::vector<ObjectId> objects;
    
    explicit VisibleObjects(const std::vector<ObjectId> & _objects) :
    objects(_objects)
    {
    }
    
    bool operator ==(const VisibleObjects & other) const
    {
        return objects == other.objects;
    }
    
    bool operator !=(const VisibleObjects & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::VisibleObjects;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << objects;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> objects;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> objects;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "VisibleObjects ( ";
        ss << "objects:( ";
        for (const auto & e : objects)
        {
            ss << e.toString() << " ";
        }
        ss << ") ";
        ss << ")";
        return ss.str();
    }
    
    VisibleObjects() {}
};

struct GetObjectInfo : public AbstractMessage
{
    int id;
    
    
    explicit GetObjectInfo(const int & _id) :
    id(_id)
    {
    }
    
    bool operator ==(const GetObjectInfo & other) const
    {
        return id == other.id;
    }
    
    bool operator !=(const GetObjectInfo & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::GetObjectInfo;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << id;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> id;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> id;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "GetObjectInfo ( ";
        ss << "id:" << id << " ";
        ss << ")";
        return ss.str();
    }
    
    GetObjectInfo() {}
};

struct FocusObject : public AbstractMessage
{
    int id;
    
    
    explicit FocusObject(const int & _id) :
    id(_id)
    {
    }
    
    bool operator ==(const FocusObject & other) const
    {
        return id == other.id;
    }
    
    bool operator !=(const FocusObject & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::FocusObject;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << id;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> id;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> id;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "FocusObject ( ";
        ss << "id:" << id << " ";
        ss << ")";
        return ss.str();
    }
    
    FocusObject() {}
};

struct SelectObject : public AbstractMessage
{
    int id;
    
    
    explicit SelectObject(const int & _id) :
    id(_id)
    {
    }
    
    bool operator ==(const SelectObject & other) const
    {
        return id == other.id;
    }
    
    bool operator !=(const SelectObject & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::SelectObject;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << id;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> id;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> id;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "SelectObject ( ";
        ss << "id:" << id << " ";
        ss << ")";
        return ss.str();
    }
    
    SelectObject() {}
};

struct ObjectCargoInfo : public AbstractMessage
{
    int id;
    int capacity;
    int carbon;
    int helium;
    
    
    explicit ObjectCargoInfo(const int & _id, const int & _capacity, const int & _carbon, const int & _helium) :
    id(_id), capacity(_capacity), carbon(_carbon), helium(_helium)
    {
    }
    
    bool operator ==(const ObjectCargoInfo & other) const
    {
        return id == other.id &&
               capacity == other.capacity &&
               carbon == other.carbon &&
               helium == other.helium;
    }
    
    bool operator !=(const ObjectCargoInfo & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::ObjectCargoInfo;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << id << capacity << carbon << helium;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> id >> capacity >> carbon >> helium;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> id >> capacity >> carbon >> helium;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ObjectCargoInfo ( ";
        ss << "id:" << id << " ";
        ss << "capacity:" << capacity << " ";
        ss << "carbon:" << carbon << " ";
        ss << "helium:" << helium << " ";
        ss << ")";
        return ss.str();
    }
    
    ObjectCargoInfo() {}
};

struct FetchAvailableActions : public AbstractMessage
{
    int shipId;
    
    
    explicit FetchAvailableActions(const int & _shipId) :
    shipId(_shipId)
    {
    }
    
    bool operator ==(const FetchAvailableActions & other) const
    {
        return shipId == other.shipId;
    }
    
    bool operator !=(const FetchAvailableActions & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::FetchAvailableActions;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << shipId;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> shipId;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> shipId;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "FetchAvailableActions ( ";
        ss << "shipId:" << shipId << " ";
        ss << ")";
        return ss.str();
    }
    
    FetchAvailableActions() {}
};

struct AvailableActions : public AbstractMessage
{
    
    std::vector<AvailableAction> actions;
    
    explicit AvailableActions(const std::vector<AvailableAction> & _actions) :
    actions(_actions)
    {
    }
    
    bool operator ==(const AvailableActions & other) const
    {
        return actions == other.actions;
    }
    
    bool operator !=(const AvailableActions & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::AvailableActions;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << actions;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> actions;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> actions;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "AvailableActions ( ";
        ss << "actions:( ";
        for (const auto & e : actions)
        {
            ss << e.toString() << " ";
        }
        ss << ") ";
        ss << ")";
        return ss.str();
    }
    
    AvailableActions() {}
};

struct ExecuteAction : public AbstractMessage
{
    int id;
    int parameter;
    bool loop;
    
    
    explicit ExecuteAction(const int & _id, const int & _parameter, const bool & _loop) :
    id(_id), parameter(_parameter), loop(_loop)
    {
    }
    
    bool operator ==(const ExecuteAction & other) const
    {
        return id == other.id &&
               parameter == other.parameter &&
               loop == other.loop;
    }
    
    bool operator !=(const ExecuteAction & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::ExecuteAction;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << id << parameter << loop;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> id >> parameter >> loop;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> id >> parameter >> loop;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ExecuteAction ( ";
        ss << "id:" << id << " ";
        ss << "parameter:" << parameter << " ";
        ss << "loop:" << loop << " ";
        ss << ")";
        return ss.str();
    }
    
    ExecuteAction() {}
};

struct ActionStarted : public AbstractMessage
{
    int objectId;
    int actionId;
    
    
    explicit ActionStarted(const int & _objectId, const int & _actionId) :
    objectId(_objectId), actionId(_actionId)
    {
    }
    
    bool operator ==(const ActionStarted & other) const
    {
        return objectId == other.objectId &&
               actionId == other.actionId;
    }
    
    bool operator !=(const ActionStarted & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::ActionStarted;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << objectId << actionId;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> objectId >> actionId;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> objectId >> actionId;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ActionStarted ( ";
        ss << "objectId:" << objectId << " ";
        ss << "actionId:" << actionId << " ";
        ss << ")";
        return ss.str();
    }
    
    ActionStarted() {}
};

struct ActionFinished : public AbstractMessage
{
    int objectId;
    int actionId;
    
    
    explicit ActionFinished(const int & _objectId, const int & _actionId) :
    objectId(_objectId), actionId(_actionId)
    {
    }
    
    bool operator ==(const ActionFinished & other) const
    {
        return objectId == other.objectId &&
               actionId == other.actionId;
    }
    
    bool operator !=(const ActionFinished & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::ActionFinished;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << objectId << actionId;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> objectId >> actionId;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> objectId >> actionId;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ActionFinished ( ";
        ss << "objectId:" << objectId << " ";
        ss << "actionId:" << actionId << " ";
        ss << ")";
        return ss.str();
    }
    
    ActionFinished() {}
};

struct ActionCooldownExpired : public AbstractMessage
{
    int actionId;
    
    
    explicit ActionCooldownExpired(const int & _actionId) :
    actionId(_actionId)
    {
    }
    
    bool operator ==(const ActionCooldownExpired & other) const
    {
        return actionId == other.actionId;
    }
    
    bool operator !=(const ActionCooldownExpired & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::ActionCooldownExpired;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << actionId;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> actionId;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> actionId;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ActionCooldownExpired ( ";
        ss << "actionId:" << actionId << " ";
        ss << ")";
        return ss.str();
    }
    
    ActionCooldownExpired() {}
};

struct GlobalCooldownActivated : public AbstractMessage
{
    
    
    
    bool operator ==(const GlobalCooldownActivated & other) const
    {
        return true;
    }
    
    bool operator !=(const GlobalCooldownActivated & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::GlobalCooldownActivated;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId();
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "GlobalCooldownActivated ( ";
        ss << ")";
        return ss.str();
    }
    
    GlobalCooldownActivated() {}
};

struct GlobalCooldownExpired : public AbstractMessage
{
    
    
    
    bool operator ==(const GlobalCooldownExpired & other) const
    {
        return true;
    }
    
    bool operator !=(const GlobalCooldownExpired & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::GlobalCooldownExpired;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId();
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "GlobalCooldownExpired ( ";
        ss << ")";
        return ss.str();
    }
    
    GlobalCooldownExpired() {}
};

struct EmitMovingMeshEffect : public AbstractMessage
{
    int fromX;
    int fromY;
    int fromZ;
    int toX;
    int toY;
    int toZ;
    int speed;
    std::string mesh;
    
    
    explicit EmitMovingMeshEffect(const int & _fromX, const int & _fromY, const int & _fromZ, const int & _toX, const int & _toY, const int & _toZ, const int & _speed, const std::string & _mesh) :
    fromX(_fromX), fromY(_fromY), fromZ(_fromZ), toX(_toX), toY(_toY), toZ(_toZ), speed(_speed), mesh(_mesh)
    {
    }
    
    bool operator ==(const EmitMovingMeshEffect & other) const
    {
        return fromX == other.fromX &&
               fromY == other.fromY &&
               fromZ == other.fromZ &&
               toX == other.toX &&
               toY == other.toY &&
               toZ == other.toZ &&
               speed == other.speed &&
               mesh == other.mesh;
    }
    
    bool operator !=(const EmitMovingMeshEffect & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::EmitMovingMeshEffect;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << fromX << fromY << fromZ << toX << toY << toZ << speed << mesh;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> fromX >> fromY >> fromZ >> toX >> toY >> toZ >> speed >> mesh;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> fromX >> fromY >> fromZ >> toX >> toY >> toZ >> speed >> mesh;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "EmitMovingMeshEffect ( ";
        ss << "fromX:" << fromX << " ";
        ss << "fromY:" << fromY << " ";
        ss << "fromZ:" << fromZ << " ";
        ss << "toX:" << toX << " ";
        ss << "toY:" << toY << " ";
        ss << "toZ:" << toZ << " ";
        ss << "speed:" << speed << " ";
        ss << "mesh:" << mesh << " ";
        ss << ")";
        return ss.str();
    }
    
    EmitMovingMeshEffect() {}
};

struct EmitExplosionEffect : public AbstractMessage
{
    int objectId;
    int directionX;
    int directionY;
    int directionZ;
    
    
    explicit EmitExplosionEffect(const int & _objectId, const int & _directionX, const int & _directionY, const int & _directionZ) :
    objectId(_objectId), directionX(_directionX), directionY(_directionY), directionZ(_directionZ)
    {
    }
    
    bool operator ==(const EmitExplosionEffect & other) const
    {
        return objectId == other.objectId &&
               directionX == other.directionX &&
               directionY == other.directionY &&
               directionZ == other.directionZ;
    }
    
    bool operator !=(const EmitExplosionEffect & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::EmitExplosionEffect;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId() << objectId << directionX << directionY << directionZ;
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        decoder >> objectId >> directionX >> directionY >> directionZ;
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        decoder >> objectId >> directionX >> directionY >> directionZ;
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "EmitExplosionEffect ( ";
        ss << "objectId:" << objectId << " ";
        ss << "directionX:" << directionX << " ";
        ss << "directionY:" << directionY << " ";
        ss << "directionZ:" << directionZ << " ";
        ss << ")";
        return ss.str();
    }
    
    EmitExplosionEffect() {}
};

struct ReloadDatabase : public AbstractMessage
{
    
    
    
    bool operator ==(const ReloadDatabase & other) const
    {
        return true;
    }
    
    bool operator !=(const ReloadDatabase & other) const
    {
        return !(*this == other);
    }
    
    Id::Messages getId() const
    {
        return Id::ReloadDatabase;
    }
    
    void serialize(Cake::Networking::Protocol::IWriteBuffer & buffer) const
    {
        Cake::Networking::Protocol::BinaryCoder coder(buffer);
        coder << getId();
    }
    
    void unserialize(Cake::Networking::Protocol::IReadBuffer & buffer)
    {
        Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
        
    }
    
    void unserialize(const Cake::Serialization::Fc & fc)
    {
        Cake::Networking::Protocol::FcDecoder decoder(fc);
        
    }
    
    std::string toString() const
    {
        std::stringstream ss;
        ss << "ReloadDatabase ( ";
        ss << ")";
        return ss.str();
    }
    
    ReloadDatabase() {}
};

struct MessageFactory
{
    	static std::shared_ptr<AbstractMessage> create(Cake::Networking::Protocol::IReadBuffer & buffer)
    	{
    		Cake::Networking::Protocol::BinaryDecoder decoder(buffer);
    		int id = Id::InvalidMessage;
    		decoder >> id;
    		std::shared_ptr<AbstractMessage> ret;
    
    		switch(id)
    		{
    		case Id::ServerVersionReq:
    			ret.reset(new ServerVersionReq());
    			break;
    
    		case Id::ServerVersionResp:
    			ret.reset(new ServerVersionResp());
    			break;
    
    		case Id::Exception:
    			ret.reset(new Exception());
    			break;
    
    		case Id::UserAuthorizationReq:
    			ret.reset(new UserAuthorizationReq());
    			break;
    
    		case Id::UserAuthorizationResp:
    			ret.reset(new UserAuthorizationResp());
    			break;
    
    		case Id::GetPlayerResourcesInfo:
    			ret.reset(new GetPlayerResourcesInfo());
    			break;
    
    		case Id::PlayerResourcesInfo:
    			ret.reset(new PlayerResourcesInfo());
    			break;
    
    		case Id::RustedTimeEpochReq:
    			ret.reset(new RustedTimeEpochReq());
    			break;
    
    		case Id::RustedTimeEpochResp:
    			ret.reset(new RustedTimeEpochResp());
    			break;
    
    		case Id::GetPlayerName:
    			ret.reset(new GetPlayerName());
    			break;
    
    		case Id::PlayerName:
    			ret.reset(new PlayerName());
    			break;
    
    		case Id::FetchPlayerShips:
    			ret.reset(new FetchPlayerShips());
    			break;
    
    		case Id::PlayerShips:
    			ret.reset(new PlayerShips());
    			break;
    
    		case Id::ShipInfo:
    			ret.reset(new ShipInfo());
    			break;
    
    		case Id::ObjectIntegrity:
    			ret.reset(new ObjectIntegrity());
    			break;
    
    		case Id::ChangeShipCourse:
    			ret.reset(new ChangeShipCourse());
    			break;
    
    		case Id::ShipCourseInfo:
    			ret.reset(new ShipCourseInfo());
    			break;
    
    		case Id::AsteroidInfo:
    			ret.reset(new AsteroidInfo());
    			break;
    
    		case Id::GetVisibleObjects:
    			ret.reset(new GetVisibleObjects());
    			break;
    
    		case Id::VisibleObjects:
    			ret.reset(new VisibleObjects());
    			break;
    
    		case Id::GetObjectInfo:
    			ret.reset(new GetObjectInfo());
    			break;
    
    		case Id::FocusObject:
    			ret.reset(new FocusObject());
    			break;
    
    		case Id::SelectObject:
    			ret.reset(new SelectObject());
    			break;
    
    		case Id::ObjectCargoInfo:
    			ret.reset(new ObjectCargoInfo());
    			break;
    
    		case Id::FetchAvailableActions:
    			ret.reset(new FetchAvailableActions());
    			break;
    
    		case Id::AvailableActions:
    			ret.reset(new AvailableActions());
    			break;
    
    		case Id::ExecuteAction:
    			ret.reset(new ExecuteAction());
    			break;
    
    		case Id::ActionStarted:
    			ret.reset(new ActionStarted());
    			break;
    
    		case Id::ActionFinished:
    			ret.reset(new ActionFinished());
    			break;
    
    		case Id::ActionCooldownExpired:
    			ret.reset(new ActionCooldownExpired());
    			break;
    
    		case Id::GlobalCooldownActivated:
    			ret.reset(new GlobalCooldownActivated());
    			break;
    
    		case Id::GlobalCooldownExpired:
    			ret.reset(new GlobalCooldownExpired());
    			break;
    
    		case Id::EmitMovingMeshEffect:
    			ret.reset(new EmitMovingMeshEffect());
    			break;
    
    		case Id::EmitExplosionEffect:
    			ret.reset(new EmitExplosionEffect());
    			break;
    
    		case Id::ReloadDatabase:
    			ret.reset(new ReloadDatabase());
    			break;
    
    		default:
    			throw std::runtime_error("unknown message id");
    		} // switch
    
    		ret->unserialize(buffer);
    
    		return ret;
    	} // create
    
        static std::shared_ptr<AbstractMessage> create(const std::string & s)
        {
            std::shared_ptr<AbstractMessage> ret;
            Cake::Serialization::Fc fc(s);
            if (fc.getName() == "ServerVersionReq")
            {
                ret.reset(new ServerVersionReq());
            }
            if (fc.getName() == "ServerVersionResp")
            {
                ret.reset(new ServerVersionResp());
            }
            if (fc.getName() == "Exception")
            {
                ret.reset(new Exception());
            }
            if (fc.getName() == "UserAuthorizationReq")
            {
                ret.reset(new UserAuthorizationReq());
            }
            if (fc.getName() == "UserAuthorizationResp")
            {
                ret.reset(new UserAuthorizationResp());
            }
            if (fc.getName() == "GetPlayerResourcesInfo")
            {
                ret.reset(new GetPlayerResourcesInfo());
            }
            if (fc.getName() == "PlayerResourcesInfo")
            {
                ret.reset(new PlayerResourcesInfo());
            }
            if (fc.getName() == "RustedTimeEpochReq")
            {
                ret.reset(new RustedTimeEpochReq());
            }
            if (fc.getName() == "RustedTimeEpochResp")
            {
                ret.reset(new RustedTimeEpochResp());
            }
            if (fc.getName() == "GetPlayerName")
            {
                ret.reset(new GetPlayerName());
            }
            if (fc.getName() == "PlayerName")
            {
                ret.reset(new PlayerName());
            }
            if (fc.getName() == "FetchPlayerShips")
            {
                ret.reset(new FetchPlayerShips());
            }
            if (fc.getName() == "PlayerShips")
            {
                ret.reset(new PlayerShips());
            }
            if (fc.getName() == "ShipInfo")
            {
                ret.reset(new ShipInfo());
            }
            if (fc.getName() == "ObjectIntegrity")
            {
                ret.reset(new ObjectIntegrity());
            }
            if (fc.getName() == "ChangeShipCourse")
            {
                ret.reset(new ChangeShipCourse());
            }
            if (fc.getName() == "ShipCourseInfo")
            {
                ret.reset(new ShipCourseInfo());
            }
            if (fc.getName() == "AsteroidInfo")
            {
                ret.reset(new AsteroidInfo());
            }
            if (fc.getName() == "GetVisibleObjects")
            {
                ret.reset(new GetVisibleObjects());
            }
            if (fc.getName() == "VisibleObjects")
            {
                ret.reset(new VisibleObjects());
            }
            if (fc.getName() == "GetObjectInfo")
            {
                ret.reset(new GetObjectInfo());
            }
            if (fc.getName() == "FocusObject")
            {
                ret.reset(new FocusObject());
            }
            if (fc.getName() == "SelectObject")
            {
                ret.reset(new SelectObject());
            }
            if (fc.getName() == "ObjectCargoInfo")
            {
                ret.reset(new ObjectCargoInfo());
            }
            if (fc.getName() == "FetchAvailableActions")
            {
                ret.reset(new FetchAvailableActions());
            }
            if (fc.getName() == "AvailableActions")
            {
                ret.reset(new AvailableActions());
            }
            if (fc.getName() == "ExecuteAction")
            {
                ret.reset(new ExecuteAction());
            }
            if (fc.getName() == "ActionStarted")
            {
                ret.reset(new ActionStarted());
            }
            if (fc.getName() == "ActionFinished")
            {
                ret.reset(new ActionFinished());
            }
            if (fc.getName() == "ActionCooldownExpired")
            {
                ret.reset(new ActionCooldownExpired());
            }
            if (fc.getName() == "GlobalCooldownActivated")
            {
                ret.reset(new GlobalCooldownActivated());
            }
            if (fc.getName() == "GlobalCooldownExpired")
            {
                ret.reset(new GlobalCooldownExpired());
            }
            if (fc.getName() == "EmitMovingMeshEffect")
            {
                ret.reset(new EmitMovingMeshEffect());
            }
            if (fc.getName() == "EmitExplosionEffect")
            {
                ret.reset(new EmitExplosionEffect());
            }
            if (fc.getName() == "ReloadDatabase")
            {
                ret.reset(new ReloadDatabase());
            }
       if (!ret)
       {
           throw std::runtime_error("no such message");
       }
       ret->unserialize(fc);
       return ret;
    }
    
    };

template<class HandlerType>
struct HandlerCaller0
{
	HandlerCaller0(HandlerType & handler) :
	m_handler(handler)
	{
	}

	void call(AbstractMessage & message)
	{
		switch(message.getId())
		{
		case Id::ServerVersionReq:
			m_handler.handle(static_cast<const ServerVersionReq&>(message)); break;

		case Id::ServerVersionResp:
			m_handler.handle(static_cast<const ServerVersionResp&>(message)); break;

		case Id::Exception:
			m_handler.handle(static_cast<const Exception&>(message)); break;

		case Id::UserAuthorizationReq:
			m_handler.handle(static_cast<const UserAuthorizationReq&>(message)); break;

		case Id::UserAuthorizationResp:
			m_handler.handle(static_cast<const UserAuthorizationResp&>(message)); break;

		case Id::GetPlayerResourcesInfo:
			m_handler.handle(static_cast<const GetPlayerResourcesInfo&>(message)); break;

		case Id::PlayerResourcesInfo:
			m_handler.handle(static_cast<const PlayerResourcesInfo&>(message)); break;

		case Id::RustedTimeEpochReq:
			m_handler.handle(static_cast<const RustedTimeEpochReq&>(message)); break;

		case Id::RustedTimeEpochResp:
			m_handler.handle(static_cast<const RustedTimeEpochResp&>(message)); break;

		case Id::GetPlayerName:
			m_handler.handle(static_cast<const GetPlayerName&>(message)); break;

		case Id::PlayerName:
			m_handler.handle(static_cast<const PlayerName&>(message)); break;

		case Id::FetchPlayerShips:
			m_handler.handle(static_cast<const FetchPlayerShips&>(message)); break;

		case Id::PlayerShips:
			m_handler.handle(static_cast<const PlayerShips&>(message)); break;

		case Id::ShipInfo:
			m_handler.handle(static_cast<const ShipInfo&>(message)); break;

		case Id::ObjectIntegrity:
			m_handler.handle(static_cast<const ObjectIntegrity&>(message)); break;

		case Id::ChangeShipCourse:
			m_handler.handle(static_cast<const ChangeShipCourse&>(message)); break;

		case Id::ShipCourseInfo:
			m_handler.handle(static_cast<const ShipCourseInfo&>(message)); break;

		case Id::AsteroidInfo:
			m_handler.handle(static_cast<const AsteroidInfo&>(message)); break;

		case Id::GetVisibleObjects:
			m_handler.handle(static_cast<const GetVisibleObjects&>(message)); break;

		case Id::VisibleObjects:
			m_handler.handle(static_cast<const VisibleObjects&>(message)); break;

		case Id::GetObjectInfo:
			m_handler.handle(static_cast<const GetObjectInfo&>(message)); break;

		case Id::FocusObject:
			m_handler.handle(static_cast<const FocusObject&>(message)); break;

		case Id::SelectObject:
			m_handler.handle(static_cast<const SelectObject&>(message)); break;

		case Id::ObjectCargoInfo:
			m_handler.handle(static_cast<const ObjectCargoInfo&>(message)); break;

		case Id::FetchAvailableActions:
			m_handler.handle(static_cast<const FetchAvailableActions&>(message)); break;

		case Id::AvailableActions:
			m_handler.handle(static_cast<const AvailableActions&>(message)); break;

		case Id::ExecuteAction:
			m_handler.handle(static_cast<const ExecuteAction&>(message)); break;

		case Id::ActionStarted:
			m_handler.handle(static_cast<const ActionStarted&>(message)); break;

		case Id::ActionFinished:
			m_handler.handle(static_cast<const ActionFinished&>(message)); break;

		case Id::ActionCooldownExpired:
			m_handler.handle(static_cast<const ActionCooldownExpired&>(message)); break;

		case Id::GlobalCooldownActivated:
			m_handler.handle(static_cast<const GlobalCooldownActivated&>(message)); break;

		case Id::GlobalCooldownExpired:
			m_handler.handle(static_cast<const GlobalCooldownExpired&>(message)); break;

		case Id::EmitMovingMeshEffect:
			m_handler.handle(static_cast<const EmitMovingMeshEffect&>(message)); break;

		case Id::EmitExplosionEffect:
			m_handler.handle(static_cast<const EmitExplosionEffect&>(message)); break;

		case Id::ReloadDatabase:
			m_handler.handle(static_cast<const ReloadDatabase&>(message)); break;

		default:
			throw std::runtime_error("unknown message id");
		} // switch
	} // call

	private:
		HandlerType & m_handler;
}; // class HandlerCaller


template<class HandlerType, class T0>
struct HandlerCaller1
{
	HandlerCaller1(HandlerType & handler) :
	m_handler(handler)
	{
	}

	void call(AbstractMessage & message, T0 p0)
	{
		switch(message.getId())
		{
		case Id::ServerVersionReq:
			m_handler.handle(static_cast<const ServerVersionReq&>(message), p0); break;

		case Id::ServerVersionResp:
			m_handler.handle(static_cast<const ServerVersionResp&>(message), p0); break;

		case Id::Exception:
			m_handler.handle(static_cast<const Exception&>(message), p0); break;

		case Id::UserAuthorizationReq:
			m_handler.handle(static_cast<const UserAuthorizationReq&>(message), p0); break;

		case Id::UserAuthorizationResp:
			m_handler.handle(static_cast<const UserAuthorizationResp&>(message), p0); break;

		case Id::GetPlayerResourcesInfo:
			m_handler.handle(static_cast<const GetPlayerResourcesInfo&>(message), p0); break;

		case Id::PlayerResourcesInfo:
			m_handler.handle(static_cast<const PlayerResourcesInfo&>(message), p0); break;

		case Id::RustedTimeEpochReq:
			m_handler.handle(static_cast<const RustedTimeEpochReq&>(message), p0); break;

		case Id::RustedTimeEpochResp:
			m_handler.handle(static_cast<const RustedTimeEpochResp&>(message), p0); break;

		case Id::GetPlayerName:
			m_handler.handle(static_cast<const GetPlayerName&>(message), p0); break;

		case Id::PlayerName:
			m_handler.handle(static_cast<const PlayerName&>(message), p0); break;

		case Id::FetchPlayerShips:
			m_handler.handle(static_cast<const FetchPlayerShips&>(message), p0); break;

		case Id::PlayerShips:
			m_handler.handle(static_cast<const PlayerShips&>(message), p0); break;

		case Id::ShipInfo:
			m_handler.handle(static_cast<const ShipInfo&>(message), p0); break;

		case Id::ObjectIntegrity:
			m_handler.handle(static_cast<const ObjectIntegrity&>(message), p0); break;

		case Id::ChangeShipCourse:
			m_handler.handle(static_cast<const ChangeShipCourse&>(message), p0); break;

		case Id::ShipCourseInfo:
			m_handler.handle(static_cast<const ShipCourseInfo&>(message), p0); break;

		case Id::AsteroidInfo:
			m_handler.handle(static_cast<const AsteroidInfo&>(message), p0); break;

		case Id::GetVisibleObjects:
			m_handler.handle(static_cast<const GetVisibleObjects&>(message), p0); break;

		case Id::VisibleObjects:
			m_handler.handle(static_cast<const VisibleObjects&>(message), p0); break;

		case Id::GetObjectInfo:
			m_handler.handle(static_cast<const GetObjectInfo&>(message), p0); break;

		case Id::FocusObject:
			m_handler.handle(static_cast<const FocusObject&>(message), p0); break;

		case Id::SelectObject:
			m_handler.handle(static_cast<const SelectObject&>(message), p0); break;

		case Id::ObjectCargoInfo:
			m_handler.handle(static_cast<const ObjectCargoInfo&>(message), p0); break;

		case Id::FetchAvailableActions:
			m_handler.handle(static_cast<const FetchAvailableActions&>(message), p0); break;

		case Id::AvailableActions:
			m_handler.handle(static_cast<const AvailableActions&>(message), p0); break;

		case Id::ExecuteAction:
			m_handler.handle(static_cast<const ExecuteAction&>(message), p0); break;

		case Id::ActionStarted:
			m_handler.handle(static_cast<const ActionStarted&>(message), p0); break;

		case Id::ActionFinished:
			m_handler.handle(static_cast<const ActionFinished&>(message), p0); break;

		case Id::ActionCooldownExpired:
			m_handler.handle(static_cast<const ActionCooldownExpired&>(message), p0); break;

		case Id::GlobalCooldownActivated:
			m_handler.handle(static_cast<const GlobalCooldownActivated&>(message), p0); break;

		case Id::GlobalCooldownExpired:
			m_handler.handle(static_cast<const GlobalCooldownExpired&>(message), p0); break;

		case Id::EmitMovingMeshEffect:
			m_handler.handle(static_cast<const EmitMovingMeshEffect&>(message), p0); break;

		case Id::EmitExplosionEffect:
			m_handler.handle(static_cast<const EmitExplosionEffect&>(message), p0); break;

		case Id::ReloadDatabase:
			m_handler.handle(static_cast<const ReloadDatabase&>(message), p0); break;

		default:
			throw std::runtime_error("unknown message id");
		} // switch
	} // call

	private:
		HandlerType & m_handler;
}; // class HandlerCaller


inline std::ostream & operator <<(std::ostream & stream, const AbstractMessage & message)
{
    return stream << message.toString();
}


} // namespace Common
} // namespace Messages
